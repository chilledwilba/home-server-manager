import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import Database from 'better-sqlite3';
import { DockerMonitor } from '../../../../src/services/monitoring/docker-monitor.js';
import { PortainerClient } from '../../../../src/integrations/portainer/client.js';

// Mock PortainerClient
jest.mock('../../../../src/integrations/portainer/client.js');

// Mock NodeJS.Timeout type if it's not available
if (typeof global.NodeJS === 'undefined') {
  (global as any).NodeJS = {
    Timeout: class Timeout {},
  };
}

describe('DockerMonitor', () => {
  let db: Database.Database;
  let monitor: DockerMonitor;
  let mockPortainerClient: jest.Mocked<PortainerClient>;

  beforeEach(() => {
    // Create in-memory database
    db = new Database(':memory:');

    // Create required tables
    db.exec(`
      CREATE TABLE containers (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        image TEXT,
        status TEXT,
        state TEXT,
        created_at TEXT,
        started_at TEXT,
        cpu_percent REAL,
        memory_usage INTEGER,
        memory_limit INTEGER,
        network_rx_bytes INTEGER,
        network_tx_bytes INTEGER,
        block_read_bytes INTEGER,
        block_write_bytes INTEGER,
        restart_count INTEGER,
        health_status TEXT,
        exit_code INTEGER,
        error TEXT,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE container_stats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        container_id TEXT NOT NULL,
        cpu_percent REAL,
        memory_usage INTEGER,
        memory_limit INTEGER,
        network_rx_bytes INTEGER,
        network_tx_bytes INTEGER,
        block_read_bytes INTEGER,
        block_write_bytes INTEGER,
        timestamp TEXT DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE stacks (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        status INTEGER,
        endpoint_id INTEGER,
        created_at TEXT,
        updated_at TEXT,
        file_content TEXT
      );
    `);

    // Create mock Portainer client
    mockPortainerClient = {
      getContainers: jest.fn(),
      getStacks: jest.fn(),
      restartContainer: jest.fn(),
      stopContainer: jest.fn(),
      startContainer: jest.fn(),
      deployStack: jest.fn(),
      deleteStack: jest.fn(),
      getVolumes: jest.fn(),
      getNetworks: jest.fn(),
      getSystemInfo: jest.fn(),
      updateStack: jest.fn(),
    } as any;

    monitor = new DockerMonitor(db, mockPortainerClient);
  });

  afterEach(() => {
    db.close();
    jest.clearAllMocks();
  });

  describe('updateContainerStatus', () => {
    it('should fetch and store container status', async () => {
      const mockContainers = [
        {
          Id: 'container1',
          Names: ['/nginx'],
          Image: 'nginx:latest',
          State: 'running',
          Status: 'Up 5 hours',
          Created: 1704067200,
          Stats: {
            CPUPercentage: 2.5,
            MemoryUsage: 100000000,
            MemoryLimit: 1000000000,
            NetworkRx: 5000000,
            NetworkTx: 3000000,
            BlockRead: 1000000,
            BlockWrite: 500000,
          },
        },
        {
          Id: 'container2',
          Names: ['/postgres'],
          Image: 'postgres:14',
          State: 'running',
          Status: 'Up 2 days',
          Created: 1703980800,
        },
      ];

      mockPortainerClient.getContainers.mockResolvedValue(mockContainers);

      await monitor.updateContainerStatus();

      // Check that containers were stored in database
      const containers = db.prepare('SELECT * FROM containers').all();
      expect(containers).toHaveLength(2);
      expect(containers[0].id).toBe('container1');
      expect(containers[0].name).toBe('nginx');
      expect(containers[0].status).toBe('Up 5 hours');
      expect(containers[1].id).toBe('container2');
      expect(containers[1].name).toBe('postgres');
    });

    it('should handle container fetch errors', async () => {
      mockPortainerClient.getContainers.mockRejectedValue(new Error('API Error'));

      await expect(monitor.updateContainerStatus()).resolves.not.toThrow();

      // Check that no containers were stored
      const containers = db.prepare('SELECT * FROM containers').all();
      expect(containers).toHaveLength(0);
    });

    it('should update existing containers', async () => {
      // Insert initial container
      db.prepare(`
        INSERT INTO containers (id, name, status, state)
        VALUES (?, ?, ?, ?)
      `).run('container1', 'nginx', 'Up 1 hour', 'running');

      const mockContainers = [
        {
          Id: 'container1',
          Names: ['/nginx'],
          Status: 'Up 5 hours', // Updated status
          State: 'running',
        },
      ];

      mockPortainerClient.getContainers.mockResolvedValue(mockContainers);

      await monitor.updateContainerStatus();

      // Check that container was updated
      const container = db.prepare('SELECT * FROM containers WHERE id = ?').get('container1');
      expect(container.status).toBe('Up 5 hours');
    });
  });

  describe('getUnhealthyContainers', () => {
    it('should identify unhealthy containers', async () => {
      // Insert test containers
      db.prepare(`
        INSERT INTO containers (id, name, status, state, health_status)
        VALUES
        (?, ?, ?, ?, ?),
        (?, ?, ?, ?, ?),
        (?, ?, ?, ?, ?)
      `).run(
        'container1', 'nginx', 'Up 5 hours', 'running', 'healthy',
        'container2', 'postgres', 'Exited (1)', 'exited', 'unhealthy',
        'container3', 'redis', 'Restarting', 'restarting', null
      );

      const unhealthy = await monitor.getUnhealthyContainers();

      expect(unhealthy).toHaveLength(2);
      expect(unhealthy.map(c => c.name)).toContain('postgres');
      expect(unhealthy.map(c => c.name)).toContain('redis');
      expect(unhealthy.map(c => c.name)).not.toContain('nginx');
    });

    it('should return empty array when all containers are healthy', async () => {
      db.prepare(`
        INSERT INTO containers (id, name, status, state, health_status)
        VALUES (?, ?, ?, ?, ?)
      `).run('container1', 'nginx', 'Up 5 hours', 'running', 'healthy');

      const unhealthy = await monitor.getUnhealthyContainers();

      expect(unhealthy).toHaveLength(0);
    });
  });

  describe('getContainerStats', () => {
    it('should retrieve container statistics', async () => {
      const containerId = 'container1';
      const now = Date.now();

      // Insert historical stats
      for (let i = 0; i < 5; i++) {
        db.prepare(`
          INSERT INTO container_stats
          (container_id, cpu_percent, memory_usage, memory_limit,
           network_rx_bytes, network_tx_bytes, timestamp)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `).run(
          containerId,
          2.5 + i * 0.5,
          100000000 + i * 1000000,
          1000000000,
          5000000 + i * 100000,
          3000000 + i * 50000,
          new Date(now - (4 - i) * 3600000).toISOString()
        );
      }

      const stats = await monitor.getContainerStats(containerId, 24);

      expect(stats).toHaveLength(5);
      expect(stats[0].container_id).toBe(containerId);
      expect(stats[0].cpu_percent).toBeGreaterThanOrEqual(2.5);
    });

    it('should limit stats by time period', async () => {
      const containerId = 'container1';
      const now = Date.now();

      // Insert old and recent stats
      db.prepare(`
        INSERT INTO container_stats
        (container_id, cpu_percent, memory_usage, timestamp)
        VALUES
        (?, ?, ?, ?),
        (?, ?, ?, ?)
      `).run(
        containerId, 2.5, 100000000, new Date(now - 25 * 3600000).toISOString(), // 25 hours old
        containerId, 3.0, 110000000, new Date(now - 1 * 3600000).toISOString()   // 1 hour old
      );

      const stats = await monitor.getContainerStats(containerId, 24);

      expect(stats).toHaveLength(1); // Only recent stat
      expect(stats[0].cpu_percent).toBe(3.0);
    });
  });

  describe('restartContainer', () => {
    it('should restart container successfully', async () => {
      mockPortainerClient.restartContainer.mockResolvedValue(true);

      const result = await monitor.restartContainer('container1');

      expect(result).toBe(true);
      expect(mockPortainerClient.restartContainer).toHaveBeenCalledWith('container1');
    });

    it('should handle restart failure', async () => {
      mockPortainerClient.restartContainer.mockResolvedValue(false);

      const result = await monitor.restartContainer('container1');

      expect(result).toBe(false);
    });
  });

  describe('getStackInfo', () => {
    it('should fetch and store stack information', async () => {
      const mockStacks = [
        {
          Id: 1,
          Name: 'monitoring',
          Status: 1,
          EndpointId: 1,
          SwarmId: 'swarm1',
        },
        {
          Id: 2,
          Name: 'media',
          Status: 1,
          EndpointId: 1,
          SwarmId: 'swarm1',
        },
      ];

      mockPortainerClient.getStacks.mockResolvedValue(mockStacks);

      const stacks = await monitor.getStackInfo();

      expect(stacks).toHaveLength(2);
      expect(stacks[0].Name).toBe('monitoring');
      expect(stacks[1].Name).toBe('media');

      // Check database storage
      const dbStacks = db.prepare('SELECT * FROM stacks').all();
      expect(dbStacks).toHaveLength(2);
    });

    it('should handle stack fetch errors', async () => {
      mockPortainerClient.getStacks.mockRejectedValue(new Error('API Error'));

      const stacks = await monitor.getStackInfo();

      expect(stacks).toEqual([]);
    });
  });

  describe('analyzeResourceUsage', () => {
    it('should analyze container resource usage', async () => {
      // Insert container with stats
      db.prepare(`
        INSERT INTO containers
        (id, name, status, state, cpu_percent, memory_usage, memory_limit)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `).run('container1', 'nginx', 'Up 5 hours', 'running', 85, 900000000, 1000000000);

      const analysis = await monitor.analyzeResourceUsage();

      expect(analysis).toBeDefined();
      expect(analysis.highCpuContainers).toHaveLength(1);
      expect(analysis.highCpuContainers[0].name).toBe('nginx');
      expect(analysis.highMemoryContainers).toHaveLength(1);
      expect(analysis.totalContainers).toBe(1);
      expect(analysis.runningContainers).toBe(1);
    });

    it('should identify resource constraints', async () => {
      // Insert multiple containers with varying resource usage
      db.prepare(`
        INSERT INTO containers
        (id, name, status, state, cpu_percent, memory_usage, memory_limit)
        VALUES
        (?, ?, ?, ?, ?, ?, ?),
        (?, ?, ?, ?, ?, ?, ?),
        (?, ?, ?, ?, ?, ?, ?)
      `).run(
        'container1', 'high-cpu', 'Up 1 hour', 'running', 95, 100000000, 1000000000,
        'container2', 'high-mem', 'Up 2 hours', 'running', 20, 950000000, 1000000000,
        'container3', 'normal', 'Up 3 hours', 'running', 10, 200000000, 1000000000
      );

      const analysis = await monitor.analyzeResourceUsage();

      expect(analysis.highCpuContainers).toHaveLength(1);
      expect(analysis.highCpuContainers[0].name).toBe('high-cpu');
      expect(analysis.highMemoryContainers).toHaveLength(1);
      expect(analysis.highMemoryContainers[0].name).toBe('high-mem');
      expect(analysis.totalContainers).toBe(3);
      expect(analysis.runningContainers).toBe(3);
    });
  });

  describe('predictContainerFailure', () => {
    it('should predict container failure based on restart patterns', async () => {
      // Insert container with high restart count
      db.prepare(`
        INSERT INTO containers
        (id, name, status, state, restart_count, exit_code)
        VALUES (?, ?, ?, ?, ?, ?)
      `).run('container1', 'unstable-app', 'Up 10 minutes', 'running', 15, 1);

      const prediction = await monitor.predictContainerFailure('container1');

      expect(prediction).toBeDefined();
      expect(prediction.riskLevel).toBe('high');
      expect(prediction.factors).toContain('high restart count');
      expect(prediction.recommendation).toContain('investigate');
    });

    it('should predict low risk for stable container', async () => {
      // Insert stable container
      db.prepare(`
        INSERT INTO containers
        (id, name, status, state, restart_count, cpu_percent, memory_usage, memory_limit)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run('container1', 'stable-app', 'Up 30 days', 'running', 0, 15, 300000000, 1000000000);

      const prediction = await monitor.predictContainerFailure('container1');

      expect(prediction).toBeDefined();
      expect(prediction.riskLevel).toBe('low');
      expect(prediction.factors).toContain('stable runtime');
    });

    it('should identify resource exhaustion risks', async () => {
      // Insert container with high resource usage
      db.prepare(`
        INSERT INTO containers
        (id, name, status, state, restart_count, cpu_percent, memory_usage, memory_limit)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run('container1', 'resource-hungry', 'Up 1 hour', 'running', 2, 95, 980000000, 1000000000);

      const prediction = await monitor.predictContainerFailure('container1');

      expect(prediction).toBeDefined();
      expect(prediction.riskLevel).not.toBe('low');
      expect(prediction.factors).toContain('high resource usage');
    });
  });
});